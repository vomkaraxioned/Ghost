"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecommendationController = void 0;
const errors_1 = __importDefault(require("@tryghost/errors"));
function validateString(object, key, { required = true, nullable = false } = {}) {
    if (typeof object !== 'object' || object === null) {
        throw new errors_1.default.BadRequestError({ message: `${key} must be an object` });
    }
    if (nullable && object[key] === null) {
        return null;
    }
    if (object[key] !== undefined && object[key] !== null) {
        if (typeof object[key] !== 'string') {
            throw new errors_1.default.BadRequestError({ message: `${key} must be a string` });
        }
        return object[key];
    }
    else if (required) {
        throw new errors_1.default.BadRequestError({ message: `${key} is required` });
    }
}
function validateBoolean(object, key, { required = true } = {}) {
    if (typeof object !== 'object' || object === null) {
        throw new errors_1.default.BadRequestError({ message: `${key} must be an object` });
    }
    if (object[key] !== undefined) {
        if (typeof object[key] !== 'boolean') {
            throw new errors_1.default.BadRequestError({ message: `${key} must be a boolean` });
        }
        return object[key];
    }
    else if (required) {
        throw new errors_1.default.BadRequestError({ message: `${key} is required` });
    }
}
function validateURL(object, key, { required = true, nullable = false } = {}) {
    const string = validateString(object, key, { required, nullable });
    if (string === null) {
        return null;
    }
    if (string !== undefined) {
        try {
            return new URL(string);
        }
        catch (e) {
            throw new errors_1.default.BadRequestError({ message: `${key} must be a valid URL` });
        }
    }
}
function validateInteger(object, key, { required = true, nullable = false } = {}) {
    if (typeof object !== 'object' || object === null) {
        throw new errors_1.default.BadRequestError({ message: `${key} must be an object` });
    }
    if (nullable && object[key] === null) {
        return null;
    }
    if (object[key] !== undefined && object[key] !== null) {
        if (typeof object[key] === 'string') {
            // Try to cast to a number
            const parsed = parseInt(object[key]);
            if (isNaN(parsed) || !isFinite(parsed)) {
                throw new errors_1.default.BadRequestError({ message: `${key} must be a number` });
            }
            return parsed;
        }
        if (typeof object[key] !== 'number') {
            throw new errors_1.default.BadRequestError({ message: `${key} must be a number` });
        }
        return object[key];
    }
    else if (required) {
        throw new errors_1.default.BadRequestError({ message: `${key} is required` });
    }
}
class RecommendationController {
    service;
    constructor(deps) {
        this.service = deps.service;
    }
    #getFrameId(frame) {
        if (!frame.options) {
            throw new errors_1.default.BadRequestError();
        }
        const id = frame.options.id;
        if (!id) {
            throw new errors_1.default.BadRequestError();
        }
        return id;
    }
    #getFramePage(frame) {
        const page = validateInteger(frame.options, 'page', { required: false, nullable: true }) ?? 1;
        if (page < 1) {
            throw new errors_1.default.BadRequestError({ message: 'page must be greater or equal to 1' });
        }
        return page;
    }
    #getFrameLimit(frame, defaultLimit = 15) {
        const limit = validateInteger(frame.options, 'limit', { required: false, nullable: true }) ?? defaultLimit;
        if (limit < 1) {
            throw new errors_1.default.BadRequestError({ message: 'limit must be greater or equal to 1' });
        }
        return limit;
    }
    #getFrameRecommendation(frame) {
        if (!frame.data || !frame.data.recommendations || !frame.data.recommendations[0]) {
            throw new errors_1.default.BadRequestError();
        }
        const recommendation = frame.data.recommendations[0];
        const cleanedRecommendation = {
            title: validateString(recommendation, 'title') ?? '',
            url: validateURL(recommendation, 'url'),
            // Optional fields
            oneClickSubscribe: validateBoolean(recommendation, 'one_click_subscribe', { required: false }) ?? false,
            reason: validateString(recommendation, 'reason', { required: false, nullable: true }) ?? null,
            excerpt: validateString(recommendation, 'excerpt', { required: false, nullable: true }) ?? null,
            featuredImage: validateURL(recommendation, 'featured_image', { required: false, nullable: true }) ?? null,
            favicon: validateURL(recommendation, 'favicon', { required: false, nullable: true }) ?? null
        };
        // Create a new recommendation
        return cleanedRecommendation;
    }
    #getFrameRecommendationEdit(frame) {
        if (!frame.data || !frame.data.recommendations || !frame.data.recommendations[0]) {
            throw new errors_1.default.BadRequestError();
        }
        const recommendation = frame.data.recommendations[0];
        const cleanedRecommendation = {
            title: validateString(recommendation, 'title', { required: false }) ?? undefined,
            url: validateURL(recommendation, 'url', { required: false }) ?? undefined,
            oneClickSubscribe: validateBoolean(recommendation, 'one_click_subscribe', { required: false }),
            reason: validateString(recommendation, 'reason', { required: false, nullable: true }),
            excerpt: validateString(recommendation, 'excerpt', { required: false, nullable: true }),
            featuredImage: validateURL(recommendation, 'featured_image', { required: false, nullable: true }),
            favicon: validateURL(recommendation, 'favicon', { required: false, nullable: true })
        };
        // Create a new recommendation
        return cleanedRecommendation;
    }
    #returnRecommendations(recommendations, meta) {
        return {
            data: recommendations.map((r) => {
                return {
                    id: r.id,
                    title: r.title,
                    reason: r.reason,
                    excerpt: r.excerpt,
                    featured_image: r.featuredImage?.toString() ?? null,
                    favicon: r.favicon?.toString() ?? null,
                    url: r.url.toString(),
                    one_click_subscribe: r.oneClickSubscribe,
                    created_at: r.createdAt,
                    updated_at: r.updatedAt
                };
            }),
            meta
        };
    }
    #buildPagination({ page, limit, count }) {
        const pages = Math.ceil(count / limit);
        return {
            page,
            limit,
            total: count,
            pages,
            prev: page > 1 ? page - 1 : null,
            next: page < pages ? page + 1 : null
        };
    }
    async addRecommendation(frame) {
        const recommendation = this.#getFrameRecommendation(frame);
        return this.#returnRecommendations([await this.service.addRecommendation(recommendation)]);
    }
    async editRecommendation(frame) {
        const id = this.#getFrameId(frame);
        const recommendationEdit = this.#getFrameRecommendationEdit(frame);
        return this.#returnRecommendations([await this.service.editRecommendation(id, recommendationEdit)]);
    }
    async deleteRecommendation(frame) {
        const id = this.#getFrameId(frame);
        await this.service.deleteRecommendation(id);
    }
    async listRecommendations(frame) {
        const page = this.#getFramePage(frame);
        const limit = this.#getFrameLimit(frame, 5);
        const order = [
            {
                field: 'createdAt',
                direction: 'desc'
            }
        ];
        const count = await this.service.countRecommendations({});
        const data = (await this.service.listRecommendations({ page, limit, order }));
        return this.#returnRecommendations(data, {
            pagination: this.#buildPagination({ page, limit, count })
        });
    }
}
exports.RecommendationController = RecommendationController;
//# sourceMappingURL=RecommendationController.js.map