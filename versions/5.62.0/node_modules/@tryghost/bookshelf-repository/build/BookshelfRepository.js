"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BookshelfRepository = void 0;
class BookshelfRepository {
    Model;
    constructor(Model) {
        this.Model = Model;
    }
    #orderToString(order) {
        if (!order || order.length === 0) {
            return;
        }
        return order.map(({ field, direction }) => `${this.entityFieldToColumn(field)} ${direction}`).join(',');
    }
    async save(entity) {
        if (entity.deleted) {
            await this.Model.destroy({ id: entity.id });
            return;
        }
        const existing = await this.Model.findOne({ id: entity.id }, { require: false });
        if (existing) {
            existing.set(this.toPrimitive(entity));
            await existing.save({}, { autoRefresh: false, method: 'update' });
        }
        else {
            await this.Model.add(this.toPrimitive(entity));
        }
    }
    async getById(id) {
        const model = await this.Model.findOne({ id }, { require: false });
        return model ? this.modelToEntity(model) : null;
    }
    async getAll({ filter, order } = {}) {
        const models = await this.Model.findAll({
            filter,
            order: this.#orderToString(order)
        });
        return (await Promise.all(models.map(model => this.modelToEntity(model)))).filter(entity => !!entity);
    }
    async getPage({ filter, order, page, limit }) {
        const models = await this.Model.findAll({
            filter,
            order: this.#orderToString(order),
            limit,
            page
        });
        return (await Promise.all(models.map(model => this.modelToEntity(model)))).filter(entity => !!entity);
    }
    async getCount({ filter } = {}) {
        const collection = this.Model.getFilteredCollection({ filter });
        return await collection.count();
    }
}
exports.BookshelfRepository = BookshelfRepository;
//# sourceMappingURL=BookshelfRepository.js.map